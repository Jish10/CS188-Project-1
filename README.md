Implementation Details

This section explains the main search algorithms implemented in Q1–Q4 of the project.
All those function are implemented in file search.py

Q1 – Depth-First Search (DFS)

File: search.py
Function: depthFirstSearch(problem)

Description:
Implements a Depth-First Search algorithm using a stack.
It explores one path completely before backtracking to try another path.

How it works:

Start from the initial state.
Push it onto a stack.
Pop the most recent node, check if it is the goal.
If not, add all unvisited successors to the stack.
Repeat until the goal is found.

Simplified code:

def depthFirstSearch(problem):
    from util import Stack
    pilha = Stack()
    inicio = problem.getStartState()
    pilha.push((inicio, []))  # (estado, caminho)
    visitados = set()

    while not pilha.isEmpty():
        estado, caminho = pilha.pop()

        if problem.isGoalState(estado):
            return caminho  # achou o objetivo!

        if estado not in visitados:
            visitados.add(estado)
            for prox, acao, custo in problem.getSuccessors(estado):
                if prox not in visitados:
                    pilha.push((prox, caminho + [acao]))

    return []
    util.raiseNotDefined()

Q2 – Breadth-First Search (BFS)

Function: breadthFirstSearch(problem)

Description:
Implements Breadth-First Search using a queue.
It explores all nodes at one depth before going deeper.

How it works:

Start from the initial state.

Push it onto a queue.
Pop the oldest node (FIFO), check if it is the goal.
Add all unvisited successors to the queue.
BFS guarantees the shortest path when all costs are equal.

Simplified code:

def breadthFirstSearch(problem):
    from util import Queue
    fila = Queue()
    inicio = problem.getStartState()
    fila.push((inicio, []))
    visitados = set([inicio])

    while not fila.isEmpty():
        estado, caminho = fila.pop()

        if problem.isGoalState(estado):
            return caminho

        for prox, acao, custo in problem.getSuccessors(estado):
            if prox not in visitados:
                visitados.add(prox)
                fila.push((prox, caminho + [acao]))

    return []

    util.raiseNotDefined()

Q3 – Uniform Cost Search (UCS)

Function: uniformCostSearch(problem)

Description:
Implements Uniform Cost Search using a priority queue.
Always expands the node with the lowest total cost.

How it works:

Use a priority queue ordered by total path cost.
Pop the node with the smallest cost.
Add successors with updated total cost.
When the goal is reached, the path is guaranteed to be optimal.

Simplified code:

def uniformCostSearch(problem):
    from util import PriorityQueue
    fila = PriorityQueue()
    inicio = problem.getStartState()
    fila.push((inicio, [], 0), 0)
    visitados = {}

    while not fila.isEmpty():
        estado, caminho, custo = fila.pop()

        if problem.isGoalState(estado):
            return caminho

        if estado in visitados and visitados[estado] <= custo:
            continue
        visitados[estado] = custo

        for prox, acao, custoPasso in problem.getSuccessors(estado):
            novoCusto = custo + custoPasso
            fila.push((prox, caminho + [acao], novoCusto), novoCusto)

    return []

    util.raiseNotDefined()

Q4 – A* Search

Function: aStarSearch(problem, heuristic)

Description:
Implements the A* search algorithm, combining cost so far (g(n)) and a heuristic estimate (h(n)).

How it works:

Use a priority queue ordered by f(n) = g(n) + h(n).
Always expand the node with the lowest estimated total cost.
When the goal is reached, the path is optimal if the heuristic is admissible.

Simplified code:

def aStarSearch(problem, heuristic=lambda s, p: 0):
    from util import PriorityQueue
    fila = PriorityQueue()
    inicio = problem.getStartState()
    fila.push((inicio, [], 0), heuristic(inicio, problem))
    visitados = {}

    while not fila.isEmpty():
        estado, caminho, custo = fila.pop()

        if problem.isGoalState(estado):
            return caminho

        if estado in visitados and visitados[estado] <= custo:
            continue
        visitados[estado] = custo

        for prox, acao, custoPasso in problem.getSuccessors(estado):
            novoCusto = custo + custoPasso
            prioridade = novoCusto + heuristic(prox, problem)
            fila.push((prox, caminho + [acao], novoCusto), prioridade)

    return []

    util.raiseNotDefined()

#This reports was generated by AI and edit by Handwork
